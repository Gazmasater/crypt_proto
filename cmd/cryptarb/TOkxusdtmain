package main

import (
	"encoding/csv"
	"errors"
	"flag"
	"fmt"
	"io"
	"os"
	"path/filepath"
	"strings"
)

type Tri struct {
	Base1, Quote1, Base2, Quote2, Base3, Quote3 string
	Sym1, Sym2, Sym3                            string
}

type Market struct {
	Symbol      string // OKX instId, напр. BTC-USDT
	Base, Quote string // baseCcy / quoteCcy
}

type Leg struct {
	From, To  string
	Symbol    string
	Action    string // BUY or SELL
	PriceSide string // ASK for BUY, BID for SELL
}

// BUY: quote -> base по ASK
// SELL: base -> quote по BID
func makeLeg(from, to string, m Market) (Leg, bool) {
	if from == m.Quote && to == m.Base {
		return Leg{From: from, To: to, Symbol: m.Symbol, Action: "BUY", PriceSide: "ASK"}, true
	}
	if from == m.Base && to == m.Quote {
		return Leg{From: from, To: to, Symbol: m.Symbol, Action: "SELL", PriceSide: "BID"}, true
	}
	return Leg{}, false
}

// DFS по 3 ребрам (рынкам) без повторов ребер: START -> ? -> ? -> START
func findRoutes3Legs(markets []Market, start string) [][]Leg {
	var routes [][]Leg

	used := make([]bool, len(markets))
	var path []Leg

	var dfs func(curr string, depth int)
	dfs = func(curr string, depth int) {
		if depth == 3 {
			if curr == start {
				cp := make([]Leg, len(path))
				copy(cp, path)
				routes = append(routes, cp)
			}
			return
		}

		for i, mk := range markets {
			if used[i] {
				continue
			}
			// рынок должен включать curr
			if mk.Base != curr && mk.Quote != curr {
				continue
			}

			// next — второй актив в паре
			var next string
			if mk.Base == curr {
				next = mk.Quote
			} else {
				next = mk.Base
			}

			leg, ok := makeLeg(curr, next, mk)
			if !ok {
				continue
			}

			used[i] = true
			path = append(path, leg)
			dfs(next, depth+1)
			path = path[:len(path)-1]
			used[i] = false
		}
	}

	dfs(start, 0)
	return routes
}

func headerIndex(h []string) map[string]int {
	m := map[string]int{}
	for i, s := range h {
		m[strings.ToLower(strings.TrimSpace(s))] = i
	}
	return m
}

func needCol(idx map[string]int, name string) (int, error) {
	i, ok := idx[name]
	if !ok {
		return 0, fmt.Errorf("нет колонки %q в CSV", name)
	}
	return i, nil
}

func readTriangles(path string) ([]Tri, error) {
	f, err := os.Open(path)
	if err != nil {
		return nil, err
	}
	defer f.Close()

	r := csv.NewReader(f)
	r.ReuseRecord = true

	h, err := r.Read()
	if err != nil {
		return nil, err
	}
	idx := headerIndex(h)

	get := func(row []string, col string) (string, error) {
		i, err := needCol(idx, col)
		if err != nil {
			return "", err
		}
		if i >= len(row) {
			return "", fmt.Errorf("строка короче заголовка: col=%s", col)
		}
		return strings.TrimSpace(row[i]), nil
	}

	var out []Tri
	for {
		row, err := r.Read()
		if errors.Is(err, io.EOF) {
			break
		}
		if err != nil {
			return nil, err
		}

		b1, err := get(row, "base1")
		if err != nil {
			return nil, err
		}
		q1, err := get(row, "quote1")
		if err != nil {
			return nil, err
		}
		b2, err := get(row, "base2")
		if err != nil {
			return nil, err
		}
		q2, err := get(row, "quote2")
		if err != nil {
			return nil, err
		}
		b3, err := get(row, "base3")
		if err != nil {
			return nil, err
		}
		q3, err := get(row, "quote3")
		if err != nil {
			return nil, err
		}

		s1, err := get(row, "symbol1")
		if err != nil {
			return nil, err
		}
		s2, err := get(row, "symbol2")
		if err != nil {
			return nil, err
		}
		s3, err := get(row, "symbol3")
		if err != nil {
			return nil, err
		}

		out = append(out, Tri{
			Base1: b1, Quote1: q1,
			Base2: b2, Quote2: q2,
			Base3: b3, Quote3: q3,
			Sym1: s1, Sym2: s2, Sym3: s3,
		})
	}
	return out, nil
}

func ensureDirForFile(path string) error {
	dir := filepath.Dir(path)
	if dir == "." || dir == "/" || dir == "" {
		return nil
	}
	return os.MkdirAll(dir, 0o755)
}

func writeRoutes(outPath string, rows [][]string) error {
	if err := ensureDirForFile(outPath); err != nil {
		return err
	}
	f, err := os.Create(outPath)
	if err != nil {
		return err
	}
	defer f.Close()

	w := csv.NewWriter(f)
	defer w.Flush()

	for _, row := range rows {
		if err := w.Write(row); err != nil {
			return err
		}
	}
	w.Flush()
	return w.Error()
}

func main() {
	in := flag.String("in", "triangles_markets_okx.csv", "input triangles CSV (from OKX generator)")
	out := flag.String("out", "triangles_usdt_routes_okx.csv", "output routes CSV")
	start := flag.String("start", "USDT", "start/end currency (cycle START -> ... -> START), default USDT")
	flag.Parse()

	tris, err := readTriangles(*in)
	if err != nil {
		fmt.Println("ERR:", err)
		os.Exit(1)
	}

	// Заголовок итогового CSV
	rows := [][]string{{
		"start", "mid1", "mid2", "end",
		"leg1_symbol", "leg1_action", "leg1_price", "leg1_from", "leg1_to",
		"leg2_symbol", "leg2_action", "leg2_price", "leg2_from", "leg2_to",
		"leg3_symbol", "leg3_action", "leg3_price", "leg3_from", "leg3_to",
	}}

	countRoutes := 0
	startCcy := strings.TrimSpace(*start)

	for _, t := range tris {
		markets := []Market{
			{Symbol: t.Sym1, Base: t.Base1, Quote: t.Quote1},
			{Symbol: t.Sym2, Base: t.Base2, Quote: t.Quote2},
			{Symbol: t.Sym3, Base: t.Base3, Quote: t.Quote3},
		}

		routes := findRoutes3Legs(markets, startCcy)
		if len(routes) == 0 {
			continue
		}

		for _, rt := range routes {
			if len(rt) != 3 {
				continue
			}
			row := []string{
				startCcy, rt[0].To, rt[1].To, startCcy,

				rt[0].Symbol, rt[0].Action, rt[0].PriceSide, rt[0].From, rt[0].To,
				rt[1].Symbol, rt[1].Action, rt[1].PriceSide, rt[1].From, rt[1].To,
				rt[2].Symbol, rt[2].Action, rt[2].PriceSide, rt[2].From, rt[2].To,
			}
			rows = append(rows, row)
			countRoutes++
		}
	}

	if err := writeRoutes(*out, rows); err != nil {
		fmt.Println("ERR: write csv:", err)
		os.Exit(1)
	}

	fmt.Printf("OKX OK: triangles=%d routes=%d -> %s\n", len(tris), countRoutes, *out)
}
